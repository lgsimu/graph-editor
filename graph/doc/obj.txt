2018.4.9
========

目标:
====
1. 设计并实现可以放置两棵JTree的容器 (2h)
2. 加载预定义组件树 (2h)
3. 加载用户定义组件树 (1h)
4. 从组件树可以向画布拖动图形 (2h)
5. 测试性能 (2h)

分解:
====
1.1 上下布局
  1.1.1 上下两部分的大小会相互影响，上面会侵占下面的空间
1.2 内容大小不影响容器大小
1.3 内容溢出时出现滚动条

2.1 树节点可拖动
2.2 捕获树节点拖动的事件
2.3 画布捕获拖动过来的transferable对象
2.4 绘制transferable对象

3.1 设计软件在用户目录中的配置文件结构
3.2 从文件载入用户定义组件树
3.3 创建一棵包装树，隐藏根节点，并将预定义树与用户定义树设置为两个子节点

4.1 为树的每个叶子节点绑定拖动事件
4.2 为叶子节点对应的数据实现序列化接口

结果:
====
1 完成
2 完成
3 进行中
4 完成

========

2018.4.10
=========

目标:
====
1 解决拖动时报异常的问题
2 解决用户定义元件分类应该显示目录图标，实际显示叶子图标的问题
3 绘制元件对应的svg文件至cell中，而不是使用统一地默认图标
4 解决图标鼠标单击时很难选中的问题
5 选中图标时，在日志中输出userObject
6 解决框选时选不中并报异常的问题
7 只能拖动叶子节点
8 了解JTree的细节，找到与节点相关的信息

分解:
====
1.1 阅读新的virtualTree部分的代码，因为融合树之前是正常的 (0.5h)
1.2 修改对应的代码 (1h)

结果:
====
1 完成
2 进行中
4 完成
6 完成
8 完成

=========

2018.4.12
=========

目标:
====
1 将预定义和用户定义的组件分别显示在两个不同的面板里
2 可以将原件拖动至画布
3 点击拖动至画布的元件时，在日志中输出附带的userObject
4 设计并实现属性编辑器
5 绘制svg图标

分解:
====
1.1 更改解析方式 (1h)
1.2 设计新的列表容器 (1h)
1.3 将解析结果显示在容器 (1h)
4.1 显示在哪个位置
4.2 显示为怎样的组件
4.3 读取属性，绘制在组件里

结果:
====
1 完成
2 完成
3 完成
4 进行中
5 放弃：因为绘制svg图标比较麻烦耗时，而且意义不大，因为该软件不是一个图形编辑软件

=========

2018.4.13
=========

目标:
====
1 多文档
2 多个图层
3 节点编号
4 连接编号
5 输入输出连接限制

分解:
====
1.1 实现多个文档的tab标题
  1.1.1 tab标题可以关闭 (1h)
    1.1.1.1 关闭时询问是否保存
  1.1.2 创建标题栏
    1.1.2.1 处理标题栏与标尺之间覆盖的问题
2.1 查看jGraphx的文档和代码，看能否支持多图层，如何支持，或自己如何实现
3.1 重绘节点
4.1 重绘连接
5.1 限制如何限制输入输出
5.2 固定连接到节点，不能移动
5.3 限制图标大小，不能resize

决策:
====
1 标题栏不能遮住标尺
2 用JTabbedPane实现多文档的容器?

结果:
====

=========

2018.4.16
=========
目标:
====
1 迁移旧项目至新模块
2 绘制连接腔


分解:
====
1.1 定义元件库的接口
1.2 定义图文档编辑器的接口
1.3 实现图文档编辑器接口
1.4 创建图文档编辑器示例应用
2.1 回答如何重绘连接的问题
2.2 回答如何在连接上绘制圆圈的问题
  2.2.1 绘制在什么位置
  2.2.2 绘制多大
2.3 回答如何在圆圈中绘制数字的问题
2.4 回答圆圈中的数字如何自增的问题

决策:
====
2.1 继承mxGraphics2DCanvas类，重载drawCell方法，覆盖mxConstants.SHAPE_CONNECTOR，重新实现mxConnectorShape的paintShape
    方法，如果cell.isEdge是true的时候，即可重绘

结果:
====
1 完成
2 进行中

=========

2018.4.17
=========
目标:
====
1 手动连接节点时时，自动生成腔节点

结果:
====
1 完成

2018.4.18
=========
目标:
====
1 在腔节点中绘制实例对应的数字
2 输出连接关系


分解:
====
2.1 回答如何遍历图中所有节点的问题 (2h)
2.2 对于每个节点，获取连接到该节点的节点，和它连出到的节点 (2h)
2.3 实现IVertex和IGraph (1h)
2.4 实现IGraphDocument的getGraph方法，每次get时，获取最新的图 (1h)

决策:
====
1.1 每个图文档对应一个腔节点计数器
1.2 每生成一个腔节点计数器加一
1.3 每删除一个腔节点计数器减一
2.1 输出IGraph
2.2 getGraph到的结果即是连接关系
2.3 只有getGraph才计算所有的连接关系
2.4 无论节点是否孤立，都捕获
2.5 如果边孤立(即边的起点没有或终点没有)，则忽略
2.6 遍历所有节点，找到其输入输出并设置，保存该点

结果:
====
1 完成

=========

2018.4.19
=========
目标:
====
1 使用api中顶一个IStencilContext加载元件库
2 禁止拖出连接箭头时，生成节点
3 修复第一次连接时，生成两个腔节点的问题
4 修复腔移动后，连接不能重绘的问题


分解:
====

决策:
====

结果:
====

=========

2018.4.20
=========
目标:
====
1 保存项目文件
2 打开项目文件


分解:
====
1.1 保存哪些内容？
1.2 保存成怎样的文件？
1.3 保存到哪里？
2.1 打开哪里的文件？
2.2 打开什么文件？
2.3 怎么根据文件绘制？

决策:
====
1.1.1 保存，是指保存一个图文档，即IGraphDocument的实例
1.1.2 图文档包含文档标题
1.1.2.1 文档标题指图文档对应的文件的名字比如test.eg
1.1.3 保存节点值和连接关系，即序列化IGraph后的内容
1.1.4 保存节点样式
1.1.5 保存节点位置
1.2 一个IGraphDocument，对应一个jar文件
1.3 保存用户选择的位置
2.1.1 从用户选择的位置打开
2.1.2 需要校验打开的文件，是不是项目文件
2.2.1 打开jar文件，必须通过isGraphDocumentFile测试的文件
2.3.1 打开文件，读取节点的值与连接关系，即反序列化后的IGraph
2.3.2 读取节点的样式
2.3.3 读取节点的位置
2.3.4 将节点的值、连接关系、样式、位置，“捏”在一起，形成满足mxGraph的接口标准的数据graphData
2.3.5 新建一个画布，将新的，携带graphData的graph放在里面
2.3.6 使用jar包做图文档文件，是因为多个文件如何集合到一个文件太麻烦，而且打开的时候，太分散，比如
      分别存样式，位置，值这些到不同的文件，打开时，对用户来说太不友好了，如果“捏”在一个文本文件中，
      以后的图片，还有别的资源，无法一起集成到这个文本文件中，所以使用jar，可以弥补这个缺点。
      jar的缺点是更改删除jar中的文件比较麻烦。读写可能比较慢。

结果:
====

=========

2018.4.21
=========
目标:
====
1 完成JarUtil.pack，并测试
2 从接口获取腔元件模板
3 绘制腔节点的外观为圆形图标
4 修复第一次会生成两个腔节点的问题
5 修复拖动腔节点时，不会重绘连入边的问题
6 接入console
7 绑定保存功能和保存菜单按钮
8 删除节点
9 加计算按钮
10 加计算函数

分解:
====


决策:
====


结果:
====

=========

2018.4.23
=========
目标:
====
1 从IStencilContext中获取腔元件，创建腔节点cell <位置0>(EditorGraph.paintCavityNodeBetween bookmark:1)
2 修复第一次连接元件后，生成两个腔节点cell的问题 <位置0>
3 修复拖动自动生成的腔节点时，连入的边不能重绘的问题 <位置0>
4 添加编辑元件编辑菜单，复制，粘贴，剪贴，删除菜单 <位置1>(EditorMenuBar.addCellEditMenu bookmark:3)
5 为上述复制，粘贴，剪贴，删除菜单添加对应的action，并可以实现对应功能

分解:
====
1.1 从context中获取腔元件模板，从该模板中获取腔节点的graph图标icon和值value
1.2 将value.clone()赋给生成的腔节点
1.3 将腔节点cell的外观改成圆形(32x32)，高亮和其它的元件一致，背景设置为1中获取的图标，并将该图标缩放为(32x32)
1.3.1 找到其它元件是在哪里绘制的，样式是怎么获取的，怎么应用上去的

决策:
====


结果:
====
1 完成
2 完成，原因是多执行了一次`addListener(mxEvent.CELL_CONNECTED, cellConnectedListener);`
3 完成
4 完成
5 完成

=========

2018.4.24
=========
目标:
====
1 完善保存图文档时，如果文档已存在，需要更新jar中对应的文件 (GraphEditor.updateDocumentJarFile)
2 完善保存文档对应的action (DocumentSaveAction)
3 完善打开文档时，从文件解析图文档的过程 (GraphEditor.openGraphDocument)
4 完善打开文档对应的action (DocumentOpenAction)

分解:
====


决策:
====


结果:
====

=========

2018.4.25
=========
目标:
====
1 定义并实现按元件类型(注意，元件类型是分组条件中的一种)分组IGraph中的节点的过程
2 定义并实现以1中的分组结果为输入，用于显示分组的IWidget组件(注意，以后需要反向传递选中了哪个节点，所以，该IWidget的输出是节点cell的vertex的id或者typeId)

分解:
====


决策:
====


结果:
====

=========

2018.4.26
=========
目标:
====
1 按照树状显示结构来组织元件库中的显示(目前为列表显示，无法直观地看到系列元件(series stencil)的整体。注意：树状显示起到的作用是部分节点分组显示的效果，而不要求数据结构本身是树状的)

分解:
====


决策:
====


结果:
====

=========

2018.4.27
=========
目标:
====
1 联合调试

分解:
====


决策:
====


结果:
====

=========

2018.4.28
=========
目标:
====
1 联合调试

分解:
====


决策:
====


结果:
====

=========